<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[当我们在调用this的时候，调用的到底是什么？]]></title>
    <url>%2F2017%2F05%2F23%2F%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E8%B0%83%E7%94%A8this%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%B0%83%E7%94%A8%E7%9A%84%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[What is this ?this到底是什么，之前我们在写到执行上下文环境时，说到this也是其中的一个对象，还有arguments,点我查看,this是JS语言当中的关键字，在C# , java中也有此关键字，使用的方法也类似。首先我们抛出一个结论：this的使用，是为了更优雅的传递对一个对象的引用。可以极大的简化代码的结构，当然，如果用不好就会很懵逼了。例一：1234567function a () &#123; return this.name;&#125;var me = &#123; name:"帅的一塌糊涂"&#125;;a.call(me); // "结果你懂的" 而不使用this时，我们的函数就需要显式的用一个参数来传递对对象的引用：1234567function a(context)&#123; return context.name;&#125;var me = &#123; name:"帅的一塌糊涂"&#125;;a(me); 不使用this冒似看上去比使用更容易理解，但实际生产中代码远远没有这么简单，要是一直使用显式参数传递上下文对象会让代码变得混乱。所以，我们应该去深入this的用法，网上的关于this的用法，一般分为4类，1，直接调用；2，作为对象的方法调用；3，作为构造函数调用；4，显式绑定call，apply调用。我认为这四种实际可分为两种情况。 Rule.No.1: this 总是指向最后调用它的那个对象：123456789101112var b = 1, c =&#123; b:2&#125;;function a () &#123; console.log(this.b)&#125;a(); // 1window.a === a; // truec.a = a;c.a(); // 2window.c.a === c.a; // true 这个例子中，我加入了window对象便于理解，实际上我们定义在全局中的函数也是这样被调用，我们书写的时候可以省略掉window，像一种小的语法糖。先说这个例子的意外情况，在声明严格模式下，不允许this默认绑定到最外层的window对象上，也就是严格模式会输出undefined。而window.c.a()之所以会输出2，就是我们说的作为对象的方法调用，对应了规则一：this总是指向最后调用它的那个对象。即便c对象处于一个非全局作用域中(其他函数作用域)调用也是这个结果。 Rule.No.2: 使用call,apply调用函数时传递的第一个参数即为this的值，俗称‘硬绑定’：12345678910111213var a = 1, b =&#123; a:2, &#125;, c = &#123;&#125;;function foo () &#123; console.log(this.a);&#125;foo.call(b); // 2foo.call(a); // undefinedfoo.call(c); // undefinedfoo.call(this); // 1foo.call(); // 1 调用call方法时，或者写入this为绑定到默认对象，此例中的默认对象为window。当作为构造函数调用时，指向构造函数也是call方法的变换，而new实例也是该方法的变种：12345678function foo () &#123; this.c=1;&#125;var a = new foo(); // 实际等价于下面代码var b = &#123;&#125;;b.__proto__ = foo.prototype;var result=foo.call(b);return typeof result ==='obj' ? result : b; 使用new关键字构造对象，等价于新建一个对象，把对象的原型绑定在函数的原型上，再到对象的作用域中调用函数，实际即把函数的this绑定到对象上，最后一步，检测返回值，网上好多关于new的定义都没写这一步，如果该函数有返回值，那么新建对象则应包含函数的返回值，否则就为对象本身。可以看出，作为构造函数调用时，this的指向为new出来的对象，都是call方法的功劳。对应了规则2。再来看一个例子：123456789var a = &#123; b : function () &#123; return function () &#123; console.log(this.c) &#125; &#125;, c:3&#125;;var c = 5;var d = &#123; c:10 &#125;;a.b()(); // 5a.b().call(a); // 3a.b().call(d); // 10 有些教程认为，a.b()()调用时this绑定到最外层的window是规则之外，个人不敢苟同，此例中a.b()返回的是一个完整的函数，函数在全局作用域调用，自然this就绑定到了最外层，同理，用call方法改变作用域后，this也绑定到了call方法的第一个参数对象中。1234567891011function foo () &#123; console.log(this.c);&#125;var a = &#123; c:3, foo:foo&#125;;var bar = a.foo;var c = 10;bar(); // 10a.foo(); // 3 这段代码来源于《你不知道的JavaScript》，书中将bar()输出为10定义为隐式丢失。这样其实比较难以理解，这里实际考察的是=函数赋值行为到底是在干什么，函数赋值给变量，变量中储存的实际上是指向函数本身内存的指针，与函数名无关。可以想象成匿名函数，函数名仅仅是一个标签，可随时更换。也就解释了foo函数依据调用环境的不同而输出不同的数字。 小结闭包，原型链，this可以说是JS语言中的三座大山，也是这门语言的基石。无论怎么深入都不过分，尤其是在现在前端框架层出不穷的时候，angular,vue,react和各种JS库，能基础运用这些框架很简单，而想了解框架背后所蕴含的思想却大不简单。而不能了解一门语言的精髓，不了解一个框架的内部构造，始终都会被新出的框架牵着鼻子走，唯有深入JS内部，知晓它的长处，不足。才能在这些新新技术中做出合适的选择，合适的取舍！]]></content>
      <tags>
        <tag>-技术 -面向对象语言 -this的指向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS作用域]]></title>
    <url>%2F2017%2F05%2F18%2FJS%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[JS引擎的工作流程上一章说到函数声明会自动提前，实际就是JS引擎的功劳，电脑CPU只能理解二进制代码，而我们书写的程序需要经过编译之后形成机器码才能输入给CPU执行，这段过程称为编译：包括词法分析-把代码分割成最小化，语法分析-重新组合代码，语义分析-生成语法树，然后是中间代码生成，再经过链接器的链接生成最后的可执行机器码。JS的作为一门解释性语言的差别体现在边编译边执行。而执行编译的便是JS引擎，比如比较著名的谷歌chrome浏览器v8引擎。 作用域的确定JS语言的作用域指的是函数和变量的可访问的范围，JS中没有块级作用域，比如if(){},for(){}这些语句块内部定义的变量外部都是能拿到的，这里不举例，与这句话相对应的是JS中只存在函数作用域和全局作用域。而作用域的创建是在函数定义的时刻，与函数是否被调用无关：123456789var c = 1;var a = function () &#123; console.log(c);&#125;;var b = function () &#123; var c = 2; a(); &#125;;b(); // 此时会打印1，而不是2 我在刚开始遇到这个问题时，百思不得其解，为什么函数会拿到外部的c，而对里面的c无动于衷，不是说好的，变量的查找是沿着作用域链一级一级往上查找，最近的最先找到么？想要弄明白这个问题，就要知道JS解析这段代码时发生了什么。JS解析一个函数的调用时，实际会载入被调用函数的执行上下文环境，这个熟悉的名字，我们常说的this，也是执行上下文环境的一部分，下面让我们来模仿一下JS引擎的思维方式，来解析一下这段代码。走起：第一步，我们在全局下提取变量声明和函数声明:全局上下文环境-代码开始开始解析cundefinedaundefinedbundefined全局上下文环境-代码解析到第8行进行赋值c1afunctionbfunction在执行到第9行时，调用b函数，同时，会创建一个b函数的新的执行上下文环境：b函数的上下文环境局部变量c2thiswindowargumentsundefined然后，引擎进入b函数内部，也就是第五行，b函数的上下文环境会被载入到上下文环境栈，一个压栈的操作：b函数的上下文环境-栈顶全局上下文环境-栈底继续解析到第7行，调用a函数，与刚才一样，创建一个a函数的上下文环境并执行压栈，但是，此时a的执行上下文中并没变量c的定义，这个时候，引擎会到创建a函数的作用域中去取值，也就是我们所说的跨域，而此时的a函数定义在全局作用域中，自然也就拿到了c=1的值并输出。那什么情况下a函数会输出c=2呢，只有当a函数身处b函数的作用域中时，也就是，a函数在b的作用域中定义。这也很好的解释了闭包的原理：123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 此例来源于:阮一峰的网络日志;按照我们刚才分析的思路，来解释一下这个例子就很容易了，首先f1返回的是一个函数，当调用这个函数的时候，JS引擎就会先进入到f2函数作用域中寻找n的值，结果当然是没有，接下来跨域到创建f2函数的f1函数作用域中寻找，找到了n=999并输出：f2函数的上下文环境-栈顶f1函数的上下文环境全局上下文环境-栈底而此时由于f2函数引用了f1函数中的变量，导致f1函数的上下文环境并不能从内存中释放，直到第9行f2函数调用结束。这也是我们常说的闭包的弊端：增加内存开销。]]></content>
      <tags>
        <tag>-技术 -面向对象作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探索JS原型链]]></title>
    <url>%2F2017%2F05%2F10%2F%E6%8E%A2%E7%B4%A2JS%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[踏入面向对象的世界最近在观看Zepto源码解析的视频时，老师又讲到了$对象与普通对象的区别，还记得《锋利的jquery》一书中说，$对象与普通对象的区别在于，$对象是一个数组结构的对象，但没有数组的push，shift方法。想必在控制台大家也注意这对”[]”。那么它内部是如何实现这个不是数组的对象呢？其实实现这个方法非常容易，也就是这个方法，体现了JS作为一门面向对象编程语言的继承功能——JS原型链。 JS原型英文解析Every JavaScript object has a prototype. The prototype is also an object.All JavaScript objects inherit their properties and methods from their prototype. JavaScript PrototypesAll JavaScript objects inherit the properties and methods from their prototype.Objects created using an object literal, or with new Object(), inherit from a prototype called Object.prototype.Objects created with new Date() inherit the Date.prototype.The Object.prototype is on the top of the prototype chain.All JavaScript objects (Date, Array, RegExp, Function, ….) inherit from the Object.prototype.More info: w3schools首先说下为什么要拉出英文的定义，我在写这篇文档时，查看了前3页的搜索“JS原型链”的文章，其中定义最清晰简洁的还要属w3school，一般来说访问这个网站需要翻墙，国内有一个汉化版，但是不全，比较新的内容没有搬过来，比如英文版的w3school有一个w3.css的小框架，用法跟bootstrap一样，都是往class标签里添加类，用起来比bootstrap更小巧。不过比较冷门。引用的英文的意思是说，每个JS对象都有一个原型，原型也是对象，JS对象从原型那里继承了属性和方法。既然每个对象都有原型，那肯定有一个顶，也就是原型链最深处的原始原型，下文也说了，即Object.prototype，但，这里有一个常见的误区，就是把原型和对象的prototype属性划等号。在ECMAScript5的语法当中，prototype是函数特有的属性，实例对象的原型则是__proto__,prototype用来存放函数继承给下一代的东西，但是直接访问是访问不到的。例一： 12345var a = function () &#123;&#125;;a.prototype.b=3;a.b; // undefinedvar b = new a();b.b; // 3 这里用new关键字构造了b对象，此时a也称为构造函数，构造函数很容易和constructor属性弄混，尤其是：12var b = new a () ;b.constructor === a; // true 这里返回的true让人觉得这是b由a构造的证据，but，实际上不是，1b.hasOwnProperty("constructor"); // false b中并没有constructor属性，那这个属性是哪里来的呢，根据原型继承，JS会沿着原型链向上查找，首先是a.prototype:123b.__proto__ === a.prototype; // truea.prototype.hasOwnProperty("constructor"); // trueb.constructor === a.prototype.constructor; // true 实际上b.constructor是a原型链上的属性，而a的原型链之所以有这个属性，也正是指出了a的原型链是a对象在实例化出来的同时由a对象构造出来存放继承属性及方法的地方。不过由于constructor属性可以随意更改，所以单凭该属性来判定函数原型的构造很危险，也并不常用。a函数对象的实例化：123var a = function () &#123;&#125;;function a() &#123;&#125;;var a = new Function () ; 以上3种方法是等价的，唯一不同的是function a () {}函数声明会前置，这里涉及到JS引擎解析代码的过程，略过不提。第3种方法也揭示了创建一个函数也是一个实例化，常用的Array，String，Boolean。实际上也是Function函数的实例化对象。12Array.__proto__ === Function.prototype; //trueBoolean.__proto__ === Function.prototype; //true 常用的数组方法，push，pop，shift，也是定义在Array的Prototype上：1console.log(Array.prototype); 回到刚开始的问题：$()对象是类数组的结构，却没有数组的方法，即$()实际的原型不是指向Array函数的prototype。例：1234var a = new Array();a.push(1); // 1a.__proto__ = new Object();a.push(2); // Uncaught TypeError 更改了a数组的原型指向，便没有了数组上定义的方法。 总结函数的prototype对象存放着该函数实例化对象继承的方法，Array等函数的定义更像是实现了一个方法集。一个面向对象编程语言当中类的概念。但并不完美，譬如函数本身无法访问到，所以便有了JS当中的特权方法，也就是另一个难点this的指向，下一章，我将会对JS的作用域进行分析，想要理解this的指向问题，闭包，实际上就是理解函数在执行时的作用域的变化。prototype对象中若是定义了一个引用类型的方法或者是属性，当其中的一个实例进行了修改操作，其原型链上的所有实例都会收到影响，所以，引用类型的方法或者属性应该避免定义在原型上，可以改用this：1234567var a = function () &#123; a.prototype.array=[1,2,3];&#125;var b = new a();var c = new a();b.array.push(4); // [1,2,3,4]console.log(c); // [1,2,3,4] 题外话这篇文章从10号晚上开始写，今天14号。比预计的进度慢，期间严重感冒，一度坐在电脑面前咳咳咳，除了上班剩下的时间都用来睡觉恢复了。今天感冒消散，赶紧把挖的洞补上。想说的是，写博客确实是一个人能力提升的好办法，从写的时候上网查资料，到转化为自己理解的语言，再进行代码测试，最后发布。这种用输出倒逼输入的过程比自己看书，看视频学习的效率要高上不少，难怪有老的程序员说，想要提高，就要自己写博客。也希望自己能够越写越顺畅~]]></content>
      <tags>
        <tag>-技术 -面向对象语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客添加功能]]></title>
    <url>%2F2017%2F05%2F03%2F%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[升级版本之前的博客用的是Hexo默认的主题，今天根据网上的攻略换成了next主题，next主题的官方文档，依次添加了评论模块，搜索，标签，其中音乐模块的添加来自如何在Hexo中添加网易云音乐。 遗留的问题，Hexo发布文章时，需要先在命令行中输入hexo g,否则页面调试时加载不出对应的文章。来必应的加载速度很慢，会出现评论无法显示的情况，体验不佳。改善建议：1，利用码云云加速，提高网站的访问速度。2，若1无显著效果，考虑将内容部署到自己的服务器上，提升稳定性。]]></content>
      <tags>
        <tag>-音乐 -功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2F2017%2F05%2F01%2Fhello%2F</url>
    <content type="text"><![CDATA[Hexo的建站之旅一直想搭建一个属于自己的博客，从3个月前用H5页面打造的简历，到今天的Hexo最初的想法是用前端技术从前台一直搭到后台，无奈时间来不及。目前正在写一个自己的库和翻看jquery的源码，同时也确实意识到不一定所有的东西都要自己造轮子，所以选择了Hexo来快速建站。提前开始自己的书写之旅。 关于代码Hexo的搭建十分简单，但是现在的版本也十分简陋，还没有进行排版和打造留言模块，接下来会添加上来。包括标签，搜索栏等等。先尝试着用MrakDown的语法发了这篇博客，也算是插了个旗帜。所以，这就是第一篇hello world了。]]></content>
      <tags>
        <tag>-随笔 -第一章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>